---
up:
related:
year: 2023
created: 2024-08-21
tags:
  - domain/powerbi
type: "[[Book]]"
ch: "00"
finished:
aliases:
---

![738addce94f844219c1caf98f4945b91|286](https://s1.vika.cn/space/2024/08/22/738addce94f844219c1caf98f4945b91)

# 每章介绍



> [!NOTE]- 介绍
> - CH07 理解 DAX 公式引擎
> 	- **FE执行查询计划采用的算法**
> 	- 数据缓存/物化/回掉 等相关概念，更深入理解了 FE如何与 SE 协作互动
> 	- 不同的 SE 会产生完全不同的 查询计划
> 	- 融合 是一种 FE 优化技术
> 	- 思考 FE 执行方式执行过程的思路
> 		- 先自己思考 FE 会如何设计查询计划
> 		- 再查看实际的查询计划，对比和自己预想的差异
> 	- 需要留意的 FE 特性
> 		- 单线程：优化 FE 通常是关键
> 		- 执行的 SE 查询通常有先后顺序
> 		- FE 没有缓存：执行步骤不缓存，设计 callback 也没缓存
> 	- 分析查询计划时间
> 		- 总时间/SE CPU 时间
> 		- FE 时间 / SE 时间
> 		- SE 查询数量 / 集中 SE 缓存的数量
> - CH08 理解查询计划
> 	- **详细解释 物理查询计划/逻辑查询计划**  CH07 的自然延伸
> 	- 查询计划结构


**Part 1 核心概念**
开篇通过优化实例概述DAX代码与表格模型的优化步骤，接着解析表格架构的核心主题，介绍必备工具集并引入查询计划概念。

[[优化DAX-CH01 介绍]]
[[优化DAX-CH02 案例介绍优化方案]]
[[优化DAX-CH03 Tabular查询架构]]
[[优化DAX-CH04 使用 PowerBI Desktop 性能分析器]]
[[优化DAX-CH05 使用 DAX Studio]]
[[优化DAX-CH06 介绍查询计划]]


**Part 2 公式引擎** 7~9
本部分将深入FE内核，剖析运算逻辑、数据缓存机制，解读查询计划并开启代码优化实践。

[[优化DAX-CH07 理解 DAX FE]]
[[优化DAX-CH08-理解查询计划]]
[[优化DAX-CH09 优化FE]]


**Part 3 VertiPaq引擎** 10~16
作为全书的重点，七个技术密度极高的章节将系统解析VertiPaq引擎。随着知识体系的深入，我们将处理大量进阶优化场景。

[[优化DAX-CH10-理解VertiPaq]]

**Part 4 基于SQL的DirectQuery** 17~19
全面探讨SQL存储引擎上的DirectQuery技术。请注意，前述章节是理解本部分内容的必备基础。  

**Part 5 复合模型**
作为表格模型的最新架构演进，复合模型因同时涉及VertiPaq和DirectQuery的技术复杂性而最具挑战性。










# CH07 理解 DAX 公式引擎 FE


### 理解 datacaches


- **公式引擎和存储引擎的分工**：在执行DAX查询时，任务会在公式引擎和存储引擎之间分配。不同的查询细微变化可能会导致截然不同的查询计划。例如，如果一个公式是可加性的（additive），那么总计是由公式引擎计算的；如果公式是不可加性的（non-additive），那么存储引擎会通过额外的查询来计算这些值。
    
- **公式引擎不直接访问数据**：公式引擎永远不会直接访问数据，它只处理数据缓存。查询的执行速度与数据缓存的大小密切相关：缓存越小，查询速度越快。
    
- **数据缓存的大小与查询复杂性相关**：数据缓存中包含的行数取决于查询的复杂性。有时，数据缓存的大小是最小的，这种情况下执行速度最优。然而，有些情况下数据缓存的大小可能超出所需，这会影响执行速度。在这种情况下，**需要学习如何减少数据缓存的大小，以减少在两个引擎之间传输数据缓存的工作量，从而提高查询性能**。


--- 

> [!NOTE]
> 
> 1. **单次查询与并行执行**：计算引擎通常一次只向VertiPaq存储引擎发送一个查询。而对于SQL的DirectQuery，可以并行执行多个存储引擎查询。但即使如此，并行执行的查询数量通常也仅限于一个小的个位数。
>     
> 2. **复杂查询与简单查询的并行化**：在存储引擎内，一个复杂的查询可以被并行化处理，与此同时，得到相同结果的多个简单查询可能需要依次执行，或者在最好的情况下只能有限度地并行化。这意味着，如果查询被分成很多小块，整体效率反而可能会降低。
>     
> 3. **最优算法**：无论使用哪种存储引擎，最优的算法通常是由少量复杂的存储引擎查询组成，然后由计算引擎进行最后的处理。这样做的目的是最小化计算引擎和存储引擎之间的通信开销，从而提高整体效率。
> 


### 理解 物化

- 其实就是存储引擎的查询结果需要被存在内存中的情况。
- 是因为不仅需要消耗数据，还需要在内存中存储数据以供后续使用。因此，物化增加了系统的内存和处理开销


### 理解 回掉

![](https://s1.vika.cn/space/2024/08/22/bc589dd91b2340eebe4750ef2da781e8)

- 只发生在存储引擎是 VertiPaq 的场景，因为很多函数功能 VertiPaq 没有，为了避免大型的物化，所以给了 VertiPaq 调用 公式引擎的能力
- 虽然公式引擎是单线程的，但是每个 VertiPaq 线程都会对应一个独立的公式引擎，所以性能的损耗主要还是来自引擎通信的开销



### 融合

- FE内的优化技术，可以减少SE的查询次数
- 垂直融合 Vertical Fusion
	- 相同的筛选上下文，计算多个度量值
	- 物理查询计划 Spool_Iterator - Cache
- 水平融合 Horizontal Fusion
	- 不同的筛选上下文，计算同一个度量值（不要求同一个度量）
	- 物理查询计划  DataPostFilter



![67d504d76e794e4f958ac6fcbcf3846c|415](https://s1.vika.cn/space/2024/08/24/67d504d76e794e4f958ac6fcbcf3846c)

![78dc0a055cf04dd3b63cfd6c44787dde|423](https://s1.vika.cn/space/2024/08/24/78dc0a055cf04dd3b63cfd6c44787dde)



![](https://s1.vika.cn/space/2024/08/24/b9a6f63f0a73480d97dd0962f36527ff)

- 物理查询计划
	- 高亮的行是 `Extend_Lookup` 操作符，它执行的是两个表达式之间的除法运算
	- 3 ～ 5 行之间，公式引擎检索了蓝色产品的销售金额
	- 6 ～ 8 行之间，检索了红色产品的销售金额

![49bd653507e848b9b11d8305d957201d|165](https://s1.vika.cn/space/2024/08/24/49bd653507e848b9b11d8305d957201d)



